<!-- BIND UNDERSTANDING -->
👩‍🦳 Final Solid Understanding:

1️⃣ Jab function ko object ke through call karte ho → this uss object ko refer karta hai.
→ student.greet() → this = student

2️⃣ Jab usi function ko ek variable mein store karke call karte ho →
→ Function akela reh jaata hai → this confused → “Main kis ghar ka hoon?” → global object (window) ya undefined ban jaata hai.

EXAMPLE:
const student = {
  name: "Aastha",
  greet: function () {
    console.log("Hi, I'm " + this.name);
  },
};

const greeting = student.greet;
greeting();  // <-- what does "this" refer to here?
  
 “Called without context” = called alone, no object in front → this = global (or undefined in strict mode)
  Context just means → Who is calling this function?

<!--REAL EXPLANATION OF THIS EXAMPLE:
  look this phle refer krta hai student ko, but jb student ke function hamne greeting ko diye, 
  tb this ko nhi pta kisko refer kre so woh globally refer krta h
  -->

  WHY WE NEED BIND?
  🎬 Scene 3: Event Handlers Got Even Messier
CODE
<!-- button.addEventListener("click", obj.sayHi); -->
When the button is clicked, this becomes the button, not obj. Devs were like:

“EXCUSE ME?! How does this keep switching sides like it’s on Bigg Boss?”

They were passing functions around (callbacks, event listeners), but losing the original object context.

🎬 Scene 4: .bind() to the Rescue
Developers were like,

“We need a way to LOCK this down, like handcuffs! 🔒”
And so, JavaScript introduced .bind() in ECMAScript 5 (2009). Finally, devs could say:
CODE
<!--   const greetBound = obj.greet.bind(obj);
setTimeout(greetBound, 1000); // Output: Hello, Aastha -->

const sayHiBound = obj.sayHi.bind(obj);
Boom. No more context drama. this is bound to obj, and it can’t run off anymore.
