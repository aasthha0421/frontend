<!-- BIND UNDERSTANDING -->
ğŸ‘©â€ğŸ¦³ Final Solid Understanding:

1ï¸âƒ£ Jab function ko object ke through call karte ho â†’ this uss object ko refer karta hai.
â†’ student.greet() â†’ this = student

2ï¸âƒ£ Jab usi function ko ek variable mein store karke call karte ho â†’
â†’ Function akela reh jaata hai â†’ this confused â†’ â€œMain kis ghar ka hoon?â€ â†’ global object (window) ya undefined ban jaata hai.

EXAMPLE:
const student = {
  name: "Aastha",
  greet: function () {
    console.log("Hi, I'm " + this.name);
  },
};

const greeting = student.greet;
greeting();  // <-- what does "this" refer to here?
  
 â€œCalled without contextâ€ = called alone, no object in front â†’ this = global (or undefined in strict mode)
  Context just means â†’ Who is calling this function?

<!--REAL EXPLANATION OF THIS EXAMPLE:
  look this phle refer krta hai student ko, but jb student ke function hamne greeting ko diye, 
  tb this ko nhi pta kisko refer kre so woh globally refer krta h
  -->

  WHY WE NEED BIND?
  ğŸ¬ Scene 3: Event Handlers Got Even Messier
CODE
<!-- button.addEventListener("click", obj.sayHi); -->
When the button is clicked, this becomes the button, not obj. Devs were like:

â€œEXCUSE ME?! How does this keep switching sides like itâ€™s on Bigg Boss?â€

They were passing functions around (callbacks, event listeners), but losing the original object context.

ğŸ¬ Scene 4: .bind() to the Rescue
Developers were like,

â€œWe need a way to LOCK this down, like handcuffs! ğŸ”’â€
And so, JavaScript introduced .bind() in ECMAScript 5 (2009). Finally, devs could say:
CODE
<!--   const greetBound = obj.greet.bind(obj);
setTimeout(greetBound, 1000); // Output: Hello, Aastha -->

const sayHiBound = obj.sayHi.bind(obj);
Boom. No more context drama. this is bound to obj, and it canâ€™t run off anymore.
